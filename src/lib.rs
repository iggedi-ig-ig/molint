pub mod basis;
mod integrals;
mod periodic_table;
mod storage;
pub mod system;

pub use integrals::{eri, kinetic, nuclear, overlap};
pub use storage::{EriTensor, SymmetricMatrix};

#[cfg(test)]
mod tests {
    use approx::assert_relative_eq;
    use nalgebra::DMatrix;

    use crate::{basis::BasisSet, system::MolecularSystem};

    const OVERLAP: &[f64] = &[
        1.00000000,
        0.11056853,
        0.69593990,
        -0.43374921,
        0.00000000,
        -0.15885114,
        0.84964153,
        0.11056853,
        1.00000000,
        0.23670392,
        0.00000000,
        0.00000000,
        0.00000000,
        0.11056853,
        0.69593990,
        0.23670392,
        1.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        0.69593990,
        -0.43374921,
        0.00000000,
        0.00000000,
        1.00000000,
        0.00000000,
        0.00000000,
        -0.43374921,
        0.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        1.00000000,
        0.00000000,
        0.00000000,
        -0.15885114,
        0.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        1.00000000,
        0.15885114,
        0.84964153,
        0.11056853,
        0.69593990,
        -0.43374921,
        0.00000000,
        0.15885114,
        1.00000000,
    ];
    const KINETIC: &[f64] = &[
        0.76003188,
        0.03761240,
        0.33750101,
        -0.52843494,
        0.00000000,
        -0.19352771,
        0.45660099,
        0.03761240,
        29.00320407,
        -0.16801096,
        0.00000000,
        0.00000000,
        0.00000000,
        0.03761240,
        0.33750101,
        -0.16801096,
        0.80812790,
        0.00000000,
        0.00000000,
        0.00000000,
        0.33750101,
        -0.52843494,
        0.00000000,
        0.00000000,
        2.52873123,
        0.00000000,
        0.00000000,
        -0.52843494,
        0.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        2.52873123,
        0.00000000,
        0.00000000,
        -0.19352771,
        0.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        2.52873123,
        0.19352771,
        0.45660099,
        0.03761240,
        0.33750101,
        -0.52843494,
        0.00000000,
        0.19352771,
        0.76003188,
    ];
    const NUCLEAR: &[f64] = &[
        -7.89258202,
        -3.68250840,
        -6.67188596,
        4.15879150,
        0.00000000,
        1.33622861,
        -6.78526813,
        -3.68250840,
        -62.26584403,
        -7.57302001,
        0.06471536,
        0.00000000,
        0.00000000,
        -3.68250840,
        -6.67188596,
        -7.57302001,
        -10.56467713,
        0.58240162,
        0.00000000,
        0.00000000,
        -6.67188596,
        4.15879150,
        0.06471536,
        0.58240162,
        -10.76283753,
        0.00000000,
        0.00000000,
        4.15879150,
        0.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        -10.32806430,
        0.00000000,
        0.00000000,
        1.33622861,
        0.00000000,
        0.00000000,
        0.00000000,
        0.00000000,
        -10.38637739,
        -1.33622861,
        -6.78526813,
        -3.68250840,
        -6.67188596,
        4.15879150,
        0.00000000,
        -1.33622861,
        -7.89258202,
    ];

    #[test]
    fn test_overlap_water_sto3g() {
        let basis_set = BasisSet::load("data/basis/STO-3G.json").unwrap();
        let system = MolecularSystem::load("data/mol/water.json", &basis_set).unwrap();

        let overlap: DMatrix<f64> = super::overlap(&system).into();
        let kinetic: DMatrix<f64> = super::kinetic(&system).into();
        let nuclear: DMatrix<f64> = super::nuclear(&system).into();

        // println!("const OVERLAP: &[f64] = &{:2.8?};", overlap.as_slice());
        // println!("const KINETIC: &[f64] = &{:2.8?};", kinetic.as_slice());
        // println!("const NUCLEAR: &[f64] = &{:2.8?};", nuclear.as_slice());

        assert_relative_eq!(overlap.as_slice(), OVERLAP, epsilon = 1e-8);
        assert_relative_eq!(kinetic.as_slice(), KINETIC, epsilon = 1e-8);
        assert_relative_eq!(nuclear.as_slice(), NUCLEAR, epsilon = 1e-8);
    }
}
